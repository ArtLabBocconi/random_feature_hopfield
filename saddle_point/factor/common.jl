import GSL: sf_log_erfc
using SpecialFunctions
using LinearAlgebra
#using Cxx
using Libdl
import Base.collect
using DelimitedFiles
using Parameters


# Importing shared library and header file
#const path_to_lib = pwd()
#addHeaderDir(path_to_lib, kind=C_System)
#Libdl.dlopen(path_to_lib * "/libOwens.so", Libdl.RTLD_GLOBAL)
#cxxinclude("owens.hpp")

using ExtractMacro
import ForwardDiff
import ForwardDiff: Dual, value, partials
# using Knet: minibatch
# using Plots; plotlyjs(size=(1000,800))

### SPECIAL FUNCTIONS ###

const F = Float64

‚à´d_(a,b,f) = quadgk(f, a, b, atol=1e-6, maxevals=10^7)[1]


G(x) = exp(-x^2/2) / F(‚àö(2œÄ))
H(x) = erfc(x /F(‚àö2)) / 2
HŒ≤(x,Œ≤) = exp(-Œ≤) + (1-exp(-Œ≤))*H(x)
GH(x) = 2 / erfcx(x/F(‚àö2)) / F(‚àö(2œÄ))
HG(x) =  F(‚àö(2œÄ))*erfcx(x/F(‚àö2)) / 2
G(x, Œº, Œî) = exp(-(x-Œº)^2/(2Œî)) / ‚àö(2œÄ*Œî)
logH(x) = sf_log_erfc(x/F(‚àö2)) - log(F(2))
# logH(x) = x < -35.0 ? G(x) / x :
#           x >  35.0 ? -x^2 / 2 - log(2œÄ) / 2 - log(x) :
#           log(H(x))

logHŒ≤(x,Œ≤) = log(HŒ≤(x,Œ≤)) #no problems with the derivative seen
GHŒ≤(x, Œ≤) = (1-exp(-Œ≤))*GH(x) / (exp(-Œ≤)/H(x) + (1-exp(-Œ≤)))

logG(x, Œº, Œî) = -(x-Œº)^2/(2Œî) - log(2œÄ*Œî)/2
logG(x) = -x^2/2 - log(2œÄ)/2

lrelu(x, Œ≥=0.1f0) = max(x, Œ≥*x)
log2cosh(x) = abs(x) + log1p(exp(-2abs(x)))
logcosh(x) = log2cosh(x) - log(2)

Œ∏fun(x) = x > 0 ? 1 : 0
crossentropy(x, Œ≥) = log(1 + exp(-2Œ≥*x))


# LOSS FUNCTIONS

square(x) = (1-x)^2 / 2
logistic(x) = log(1+exp(-x))
hinge(x) = max(0, 1-x)


abstract type AbstractParams end

### AUTOMATIC DIFFERENTIATION ###

grad = ForwardDiff.derivative
@inline function logH(d::Dual{T}) where T
    return Dual{T}(logH(value(d)), -GH(value(d)) * partials(d))
end

@inline function HG(d::Dual{T}) where T
    return Dual{T}(HG(value(d)), (value(d) * HG(value(d))-1) * partials(d))
end


argOwen(h,z) = exp(-h^2*(1+z^2)/2) / (2œÄ*(1+z^2))
@inline function owenT(h, a::Dual{T}) where T
    #@show h, a
    return Dual{T}(owenT(h, value(a)), argOwen(h, value(a)) * partials(a))
end

@inline function owenT(h::Dual{T}, a) where T
    #@show h, a
    return Dual{T}(owenT(value(h), a), 0.5*G(value(h))*(1 - 2*H(-a*value(h))) * partials(h))
end

@inline function owenT(h::Dual{T}, a::Dual{T}) where T
    #@show h, a
    return Dual{T}(owenT(value(h), value(a)), 0.5*G(value(h))*(1 - 2*H(-value(a)*value(h))) * partials(h) + argOwen(value(h), value(a)) * partials(a))
end


### NUMERICAL DIFFERENTIATION ####

# Numerical Derivative
# Can take also directional derivative
# (tune the direction with i and Œ¥).
function deriv(f::Function, i, x...; Œ¥ = 1e-5)
    x1 = deepcopy(x) |> collect
    x1[i] += Œ¥ #x1[i] .+= Œ¥??????
    f0 = f(x...)
    f1 = f(x1...)
    return (f1-f0) / norm(Œ¥)
end

# Numerical Derivative for member of the structured input
function deriv_(f::Function, i::Int, x...; arg=1, Œ¥=1e-5)
    x1 = deepcopy(x)
    setfield!(x1[arg], i, getfield(x1[arg], i) + Œ¥)
    f0 = f(x...)
    f1 = f(x1...)
    return (f1-f0) / Œ¥
end



# x is to update; func is the function that updates x, and has params as arguments; Œî is the error; œà the damping
macro update(x, func, Œî, œà, verb, params...)
    name = string(x.args[2].value)
    # name = string(x.args[2].args[1]) # j0.6

    # if x isa Symbol || x.head == :ref
        # name = string(x.args[1], " ", eval(x.args[2]))
    # else
    #     name = string(x.args[2].args[1])
    # end
    x = esc(x)
    Œî = esc(Œî)
    œà = esc(œà)
    verb = esc(verb)
    params = map(esc, params)
    fcall = Expr(:call, func, params...)
    quote
        oldx = $x
        newx = $fcall
        abserr = norm(newx - oldx)     # p=2 by default, so |newx-oldx|
        relerr = abserr == 0 ? 0 : abserr / ((norm(newx) + norm(oldx)) / 2)
        $Œî = max($Œî, min(abserr, relerr))
        $x = (1 - $œà) * newx + $œà * oldx
        $verb > 1 && println("  ", $name, " = ", $x)
    end
end

macro updateI(x, ok, func, Œî, œà, verb, params...)
    n = string(x.args[2].value)
    # n = string(x.args[2].args[1]) # j0.6
    x = esc(x)
    ok = esc(ok)
    Œî = esc(Œî)
    œà = esc(œà)
    verb = esc(verb)
    func = esc(func)
    params = map(esc, params)
    fcall = Expr(:call, func, params...)
    quote
        oldx = $x
        $ok, newx = $fcall
        if $ok
            abserr = abs(newx - oldx)
            relerr = abserr == 0 ? 0 : abserr / ((abs(newx) + abs(oldx)) / 2)
            $Œî = max($Œî, min(abserr, relerr))
            $x = (1 - $œà) * newx + $œà * oldx
            $verb > 1 && println("  ", $n, " = ", $x)
        else
            $verb > 1 && println("  ", $n, " = ", $x)
        end
    end
end


######## FILE PRINTING ######################

function exclusive(f::Function, fn::AbstractString = "lock.tmp")
    run(`lockfile -1 $fn`)
    try
        f()
    finally
        run(`rm -f $fn`)
    end
end

function shortshow(io::IO, x)
    T = typeof(x)
    print(io, T.name.name, "(", join([string(f, "=", getfield(x, f)) for f in fieldnames(T)], ","), ")")
end

function plainshow(x)
    T = typeof(x)
    join([getfield(x, f) for f in fieldnames(T)], " ")
end

function headershow(io::IO, T::Type, i0 = 0)
    print(io, join([string(i+i0,"=",f) for (i,f) in enumerate(fieldnames(T))], " "))
    return i0 + length(fieldnames(T))
end

function headershow(io::IO, x::String, i0 = 0)
    i0 += 1
    print(io, string(i0,"=",x," "))
    i0
end

function allheadersshow(io::IO, x...)
    i0 = 0
    print(io, "#")
    for y in x
        i0 = headershow(io, y, i0)
        print(io, " ")
    end
    println(io)
end

####### ROOT FINDING ##########

# using Roots: find_zero

# function findroot(f, x0; ftol=1e-8)
#     x = find_zero(f, x0, ftol=ftol)
#     return true, x
# end

using NLsolve: nlsolve, n_ary

function findroot(f, x0; ftol=1e-8)
    res = nlsolve(n_ary(f), [x0], ftol=ftol)
    true, res.zero[1]
end

function findroots(f!, x0; ftol=1e-8)
    res = nlsolve(f!, x0, ftol=ftol)
    res.zero[1], res.zero[2], res.zero[3]
end


# function findroot(f, x0; ftol=1e-8)
#     ok, x, it, normf0 = newton(f, x0, NewtonMethod(atol=ftol))
#     return ok, x
# end



#### NEWTON ####################

# authors: Carlo Baldassi and Carlo Lucibello
"""
    type NewtonMethod <: AbstractRootsMethod
        dx::Float64
        maxiters::Int
        verb::Int
        atol::Float64
    end
Type containg the parameters for Newton's root finding algorithm.
The default parameters are:
    NewtonMethod(dx=1e-7, maxiters=1000, verb=0, atol=1e-10)
"""
mutable struct NewtonMethod
    dx::Float64
    maxiters::Int
    verb::Int
    atol::Float64
end

mutable struct NewtonParameters
    Œ¥::Float64
    œµ::Float64
    verb::Int
    maxiters::Int
end

NewtonMethod(; dx=1e-7, maxiters=1000, verb=0, atol=1e-10) =
                                    NewtonMethod(dx, maxiters, verb, atol)

function ‚àá!(‚àÇf::Matrix, f::Function, x0, Œ¥, f0, x1)
    n = length(x0)
    copy!(x1, x0)
    for i = 1:n
        x1[i] += Œ¥
        ‚àÇf[:,i] = (f(x1) - f0) / Œ¥
        x1[i] = x0[i]
    end
    #=cf = copy(‚àÇf)=#
    #=@time ‚àÇf[:,:] = @parallel hcat for i = 1:n
        x1[i] += Œ¥
        d = (f(x1) - f0) / Œ¥
        x1[i] = x0[i]
        d
    end=#
    #@assert cf == ‚àÇf
end

‚àá(f::Function, x0::Real, Œ¥::Real, f0::Real) = (f(x0 + Œ¥) - f0) / Œ¥

"""
    newton(f, x‚ÇÄ, pars=NewtonMethod())
Apply Newton's method with parameters `pars` to find a zero of `f` starting from the point
`x‚ÇÄ`.
The derivative of `f` is computed by numerical discretization. Multivariate
functions are supported.
Returns a tuple `(ok, x, it, normf)`.
**Usage Example**
ok, x, it, normf = newton(x->exp(x)-x^4, 1.)
ok || normf < 1e-10 || warn("Newton Failed")
"""
#note that in 1.0 warnings are eliminated at all
function newton(f, x‚ÇÄ::Float64, m=NewtonMethod())
    Œ∑ = 1.0
    ‚àÇf = 0.0
    x = x‚ÇÄ
    x1 = 0.0
    f0 = f(x)
    #@assert isa(f0, Real)
    normf0 = abs(f0)
    it = 0
    while normf0 ‚â• m.atol
        #m.verb > 1 && println("normf0 = $normf0, maximum precision = $(m.atol)")
        it > m.maxiters && return (false, x, it, normf0)
        it += 1
        if m.verb > 1
            println("(ùî´) it=$it")
            println("(ùî´)   x=$x")
            println("(ùî´)   f(x)=$f0")
            println("(ùî´)   normf=$(abs(f0))")
            println("(ùî´)   Œ∑=$Œ∑")
        end
        Œ¥ = m.dx
        while true
            #‚àÇf = ‚àá(f, x, Œ¥, f0)
            try
                #‚àÇf = grad(f, x)
                #m.verb > 1 && println("‚àáf = $(‚àÇf)")
                ‚àÇf = ‚àá(f, x, Œ¥, f0)
                f1 = f(x + Œ¥)
                #‚àÇf_fd = grad(f, x)
                #m.verb > 1 && println("f1 = $(f1)\n ‚àáf = $(‚àÇf) \t With FD: ‚àáf = $(‚àÇf_fd) \t difference: Fd-num=$(‚àÇf_fd-‚àÇf)")
                m.verb > 1 && println("f1 = $(f1)\n ‚àáf = $(‚àÇf)")
                break
            catch err
                #warn("newton: catched error:")
                #Base.display_error(err, catch_backtrace())
                Œ¥ /= 2
                #warn("new Œ¥ = $Œ¥")
            end
            if Œ¥ < 1e-20
                #normf0 ‚â• m.atol && warn("newton:  Œ¥=$Œ¥")
                println("Problema di Œ¥!!")
                return (false, x, it, normf0)
            end
        end
        Œîx = -f0 / ‚àÇf
        m.verb > 1 && println("(ùî´)  Œîx=$Œîx")
        while true
            x1 = x + Œîx * Œ∑
            local new_f0, new_normf0
            try
                new_f0 = f(x1)
                new_normf0 = abs(new_f0)
            catch err
                #warn("newton: catched error:")
                #Base.display_error(err, catch_backtrace())
                new_normf0 = Inf
            end
            if new_normf0 < normf0
                Œ∑ = min(1.0, Œ∑ * 1.1)
                f0 = new_f0
                normf0 = new_normf0
                x = x1
                break
            end
            # Œ∑ is lowered if f(x1) fails, or if new_normf0 ‚â• normf0
            Œ∑ /= 2
            #Œ∑ problem arises when the derivatives for example is ‚âà 0 and x1 is really different from x and the new_normf0 ‚â´ normf0
            Œ∑ < 1e-20 && println("Problema di Œ∑!!")
            Œ∑ < 1e-20 && return (false, x, it, normf0)
        end
    end
    return true, x, it, normf0
end

function newton(f::Function, x‚ÇÄ, pars::NewtonParameters)
    Œ∑ = 1.0
    n = length(x‚ÇÄ)
    ‚àÇf = Array{Float64}(undef, n, n)
    x = Float64[x‚ÇÄ[i] for i = 1:n]  #order parameters
    x1 = Array{Float64}(undef, n)

    f0 = f(x)                       #system of equation
    @assert length(f0) == n
    @assert isa(f0, Union{Real,Vector})
    normf0 = norm(f0) #previous version and in the following: vecnorm--->norm
    it = 0
    while normf0 ‚â• pars.œµ
        it > pars.maxiters && return (false, x, it, normf0)
        it += 1
        if pars.verb > 1
            println("(ùî´) it=$it")
            println("(ùî´)   x=$x")
            println("(ùî´)   f0=$f0")
            println("(ùî´)   norm=$(norm(f0))")
            println("(ùî´)   Œ∑=$Œ∑")
        end
        Œ¥ = pars.Œ¥
        while true
            try
                ‚àá!(‚àÇf, f, x, Œ¥, f0, x1)
                break
            catch
                Œ¥ /= 2
            end
            if Œ¥ < 1e-15
                #normf0 ‚â• pars.œµ && warn("newton:  Œ¥=$Œ¥")
                return (false, x, it, normf0)
            end
        end
        if isa(f0, Vector)
            Œîx = -‚àÇf \ f0
        else
            Œîx = -f0 / ‚àÇf[1,1]
        end
        pars.verb > 1 && println("(ùî´)  Œîx=$Œîx")
        while true
            for i = 1:n
                x1[i] = x[i] + Œîx[i] * Œ∑
            end
            local new_f0, new_normf0
            try
                new_f0 = f(x1)
                new_normf0 = norm(new_f0)
            catch
                new_normf0 = Inf
            end
            if new_normf0 < normf0
                Œ∑ = min(1.0, Œ∑ * 1.1)
                if isa(f0, Vector)
                    copy!(f0, new_f0)
                else
                    f0 = new_f0
                end
                normf0 = new_normf0
                copy!(x, x1)
                break
            end
            Œ∑ /= 2
            Œ∑ < 1e-15 && return (false, x, it, normf0)
        end
    end
    return true, x, it, normf0
end
